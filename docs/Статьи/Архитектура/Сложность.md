---
share: true
alias: complexity
---

Сложность это все что связано со структурой программного обеспечение и мешает пониманию и внесению изменений в систему.

Ерик Эванс в книге Domain-Driven Design: Tackling Complexity in the Heart of Software говорил, что человеку сложно судить одновременно о многих вещах (высокая [[Статьи/Архитектура/Архитектура Приложений/Coupling|связанность]]) и также сложно понимать логически не связанные друг с другом идеи (низкая [[Статьи/Архитектура/Архитектура Приложений/Cohesion|сочетаемость]]). Это следует учитывать при проектировании системы

С многими проблемами мы не можем бороться, но можем их перенести в место, где у нас больше экспертизы, преимущества и рычагов, чтобы повлиять на  решение проблемы.

## Типы сложности
Сложность в программах делится на два типа:
1. Необходимая сложность (essential complexity) - сложность предметной области, от которой невозможно никуда деться и ей практически невозможно управлять.
2. Побочная сложность (accidental complexity) - сложность, которая добавляется инструментами или неправильными решениями при проектировании самим программистом

Больше всего времени в проекте уходит на осознание бизнес области, на составление четких и непротиворечивых требований. То есть больше всего времени уходит на "необходимую сложность", которой мы не можем управлять. Если мы сможем свести к нулю всю побочную сложность, например через системы вроде low code или помощников на основе искусственного интеллекта. То это если и снизит нагрузку на разработчика, но все равно не даст роста производительности на порядки, как некоторые думают.

## Цитаты
>[!quote]
>Недостаток гибких решений в том, что за гибкость приходится платить. Гибкие решения сложнее обычных. И весьма разочаровывает, когда вся эта гибкость оказывается не нужна. В итоге может потребоавться лишь какая то часть ее, но невозможно заранее сказать какая. Поэтому чтобы достичь гибкости, приходится вводить ее гораздо больше, чем требуется в действительности.
>\-- "Refactoring: Improving the Design of Existing Code"

>[!quote]
>Рефакторинг предоставляет другой подход к рискам модификации. Возможные изменения все равно надо пытаться предвидеть, как и рассматривать гибкие решения. Но вместо реализации этих гибких решений следует задаться вопросом: "Насколько сложно будет с помощью рефакторинга преобразовать обычное решение в гибкое?" Если, как чаще всего случается, ответ будет "весьма несложно", то надо просто реализовать обычное решение.
>
>Рефакторинг позволяет создавать более простые проекты, не жертвуя гибкостью, благодаря чему процесс проектирования становится более легким и менее напряженным. Научившись в целом распознавать то, что легко поддается рефакторингу, о гибкости решений даже перестаешь задумываться. Появляется уверенность в возможности применения рефакторинга, когда это понадобится. Создаются самые простые решения, которые могут работать, а гибкие и сложные решения по большей части не потребуются. 
>\-- "Refactoring: Improving the Design of Existing Code"

>[!quote]
>Простота это высшая форма сложности. 
>\-- Леонардо Да Винчи

>[!quote]
>Сначала художник рисует плохо и просто. Потом сложно и плохо. Потом сложно и хорошо. И только потом - просто и хорошо." 
>\-- И.Е. Репин

Второе предложение этого высказывания, "потом сложно и плохо", демонстрирует собою [[Статьи/Архитектура/Архитектура Систем/Синдром второй системы|синдром второй системы]].

## Ссылки
- [Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks - YouTube](https://www.youtube.com/watch?v=FyCYva9DhsI)
