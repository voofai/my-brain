---
share: true
---

Анемичная доменная модель это паттерн написания кода при котором объекты в программе содержат только данные вместе с геттерами и сеттерами, а вся бизнес логика вынесена в отдельные классы-сервисы.Является противоположностью [[Статьи/Архитектура/Архитектура Приложений/Rich domain model|Rich domain model]]

# Пример

```java
public class OrderService {

    public void addItemToOrder(Order order, OrderItem item) {
        int sum = order.getTotal() + item.getPrice();
        order.getItems().add(item);
        order.setTotal(sum)
    }
}
```

# Связь с ООП

В [[Статьи/ООП/ООП|ООП]] парадигме анемичная модель считается антипаттерном из за нарушения принципа инкапсуляции. Сами объекты не поддерживают целостность своего состояния. И знания о том, какое состояние объекта считать правильным расползается по всему коду.

# Когда применять?

Хорошо подходит для модулей с простой бизнес логикой и для задач интеграции. Для сложной бизнес логики лучше выбрать [[Статьи/Архитектура/Архитектура Приложений/Rich domain model|Rich domain model]]. 

# Связь с функциональным программированием

К ФП данный антипаттерн не применим. Так как в ФП все данные являются иммутабельными, а инкапсуляция достигается при помощи системы модулей. Тип данных описывается в одном модуле вместе с функциями, которые с ним работают, и только эти функции умеют порождать объекты этого типа. Конструктор же типа не импортируется из модуля. Таким образом создать новый экземпляр типа возможно только вызвав функцию этого модуля.

# Ссылки

- [AnemicDomainModel](https://www.martinfowler.com/bliki/AnemicDomainModel.html)
- [Пример приложения](https://github.com/neherim/java-guild-katas/tree/master/money-transfer/money-transfer-anemic)
